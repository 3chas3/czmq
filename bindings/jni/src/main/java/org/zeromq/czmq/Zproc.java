/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/
package org.zeromq.czmq;

public class Zproc {
    static {
        try {
            System.loadLibrary ("czmqjni");
        }
        catch (Exception e) {
            System.exit (-1);
        }
    }
    public long self;
    /*
    Returns CZMQ version as a single 6-digit integer encoding the major
    version (x 10000), the minor version (x 100) and the patch.        
    */
    native static int __czmqVersion ();
    public int czmqVersion () {
        return __czmqVersion ();
    }
    /*
    Returns true if the process received a SIGINT or SIGTERM signal.
    It is good practice to use this method to exit any infinite loop
    processing messages.                                            
    */
    native static boolean __interrupted ();
    public boolean interrupted () {
        return __interrupted ();
    }
    /*
    Return current host name, for use in public tcp:// endpoints.
    If the host name is not resolvable, returns NULL.            
    */
    native static String __hostname ();
    public String hostname () {
        return __hostname ();
    }
    /*
    Move the current process into the background. The precise effect     
    depends on the operating system. On POSIX boxes, moves to a specified
    working directory (if specified), closes all file handles, reopens   
    stdin, stdout, and stderr to the null device, and sets the process to
    ignore SIGHUP. On Windows, does nothing. Returns 0 if OK, -1 if there
    was an error.                                                        
    */
    native static void __daemonize (String workdir);
    public void daemonize (String workdir) {
        __daemonize (workdir);
    }
    /*
    Drop the process ID into the lockfile, with exclusive lock, and   
    switch the process to the specified group and/or user. Any of the 
    arguments may be null, indicating a no-op. Returns 0 on success,  
    -1 on failure. Note if you combine this with zsys_daemonize, run  
    after, not before that method, or the lockfile will hold the wrong
    process ID.                                                       
    */
    native static void __runAs (String lockfile, String group, String user);
    public void runAs (String lockfile, String group, String user) {
        __runAs (lockfile, group, user);
    }
    /*
    Configure the number of I/O threads that ZeroMQ will use. A good  
    rule of thumb is one thread per gigabit of traffic in or out. The 
    default is 1, sufficient for most applications. If the environment
    variable ZSYS_IO_THREADS is defined, that provides the default.   
    Note that this method is valid only before any socket is created. 
    */
    native static void __setIoThreads (long ioThreads);
    public void setIoThreads (long ioThreads) {
        __setIoThreads (ioThreads);
    }
    /*
    Configure the number of sockets that ZeroMQ will allow. The default  
    is 1024. The actual limit depends on the system, and you can query it
    by using zsys_socket_limit (). A value of zero means "maximum".      
    Note that this method is valid only before any socket is created.    
    */
    native static void __setMaxSockets (long maxSockets);
    public void setMaxSockets (long maxSockets) {
        __setMaxSockets (maxSockets);
    }
    /*
    Return maximum number of ZeroMQ sockets that the system will support.
    */
    native static long __maxSockets ();
    public long maxSockets () {
        return __maxSockets ();
    }
    /*
    Configure the default linger timeout in msecs for new zsock instances. 
    You can also set this separately on each zsock_t instance. The default 
    linger time is zero, i.e. any pending messages will be dropped. If the 
    environment variable ZSYS_LINGER is defined, that provides the default.
    Note that process exit will typically be delayed by the linger time.   
    */
    native static void __setLinger (long linger);
    public void setLinger (long linger) {
        __setLinger (linger);
    }
    /*
    Configure the default outgoing pipe limit (HWM) for new zsock instances.
    You can also set this separately on each zsock_t instance. The default  
    HWM is 1,000, on all versions of ZeroMQ. If the environment variable    
    ZSYS_SNDHWM is defined, that provides the default. Note that a value of 
    zero means no limit, i.e. infinite memory consumption.                  
    */
    native static void __setSndhwm (long sndhwm);
    public void setSndhwm (long sndhwm) {
        __setSndhwm (sndhwm);
    }
    /*
    Configure the default incoming pipe limit (HWM) for new zsock instances.
    You can also set this separately on each zsock_t instance. The default  
    HWM is 1,000, on all versions of ZeroMQ. If the environment variable    
    ZSYS_RCVHWM is defined, that provides the default. Note that a value of 
    zero means no limit, i.e. infinite memory consumption.                  
    */
    native static void __setRcvhwm (long rcvhwm);
    public void setRcvhwm (long rcvhwm) {
        __setRcvhwm (rcvhwm);
    }
    /*
    Configure use of IPv6 for new zsock instances. By default sockets accept   
    and make only IPv4 connections. When you enable IPv6, sockets will accept  
    and connect to both IPv4 and IPv6 peers. You can override the setting on   
    each zsock_t instance. The default is IPv4 only (ipv6 set to false). If the
    environment variable ZSYS_IPV6 is defined (as 1 or 0), this provides the   
    default. Note: has no effect on ZMQ v2.                                    
    */
    native static void __setIpv6 (boolean ipv6);
    public void setIpv6 (boolean ipv6) {
        __setIpv6 (ipv6);
    }
    /*
    Return use of IPv6 for zsock instances.
    */
    native static boolean __ipv6 ();
    public boolean ipv6 () {
        return __ipv6 ();
    }
    /*
    Set network interface name to use for broadcasts, particularly zbeacon.    
    This lets the interface be configured for test environments where required.
    For example, on Mac OS X, zbeacon cannot bind to 255.255.255.255 which is  
    the default when there is no specified interface. If the environment       
    variable ZSYS_INTERFACE is set, use that as the default interface name.    
    Setting the interface to "*" means "use all available interfaces".         
    */
    native static void __setInterface (String value);
    public void setInterface (String value) {
        __setInterface (value);
    }
    /*
    Return network interface to use for broadcasts, or "" if none was set.
    */
    native static String __interface ();
    public String interface () {
        return __interface ();
    }
    /*
    Set log identity, which is a string that prefixes all log messages sent
    by this process. The log identity defaults to the environment variable 
    ZSYS_LOGIDENT, if that is set.                                         
    */
    native static void __logSetIdent (String value);
    public void logSetIdent (String value) {
        __logSetIdent (value);
    }
    /*
    Sends log output to a PUB socket bound to the specified endpoint. To   
    collect such log output, create a SUB socket, subscribe to the traffic 
    you care about, and connect to the endpoint. Log traffic is sent as a  
    single string frame, in the same format as when sent to stdout. The    
    log system supports a single sender; multiple calls to this method will
    bind the same sender to multiple endpoints. To disable the sender, call
    this method with a null argument.                                      
    */
    native static void __logSetSender (String endpoint);
    public void logSetSender (String endpoint) {
        __logSetSender (endpoint);
    }
    /*
    Enable or disable logging to the system facility (syslog on POSIX boxes,
    event log on Windows). By default this is disabled.                     
    */
    native static void __logSetSystem (boolean logsystem);
    public void logSetSystem (boolean logsystem) {
        __logSetSystem (logsystem);
    }
    /*
    Log error condition - highest priority
    */
    native static void __logError (String format);
    public void logError (String format) {
        __logError (format);
    }
    /*
    Log warning condition - high priority
    */
    native static void __logWarning (String format);
    public void logWarning (String format) {
        __logWarning (format);
    }
    /*
    Log normal, but significant, condition - normal priority
    */
    native static void __logNotice (String format);
    public void logNotice (String format) {
        __logNotice (format);
    }
    /*
    Log informational message - low priority
    */
    native static void __logInfo (String format);
    public void logInfo (String format) {
        __logInfo (format);
    }
    /*
    Log debug-level message - lowest priority
    */
    native static void __logDebug (String format);
    public void logDebug (String format) {
        __logDebug (format);
    }
    /*
    Self test of this class.
    */
    native static void __test (boolean verbose);
    public static void test (boolean verbose) {
        __test (verbose);
    }
}
