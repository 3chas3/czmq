/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/
package org.zeromq.czmq;

public class Zloop implements AutoCloseable{
    static {
        try {
            System.loadLibrary ("czmqjni");
        }
        catch (Exception e) {
            System.exit (-1);
        }
    }
    long self;
    /*
    Create a new zloop reactor
    */
    native static long __new ();
    public Zloop () {
        /*  TODO: if __new fails, self is null...  */
        self = __new ();
    }
    /*
    Destroy a reactor
    */
    native static void __destroy (long self);
    @Override
    public void close () {
        __destroy (self);
        self = 0;
    }
    /*
    Register socket reader with the reactor. When the reader has messages, 
    the reactor will call the handler, passing the arg. Returns 0 if OK, -1
    if there was an error. If you register the same socket more than once, 
    each instance will invoke its corresponding handler.                   
    */
    native static int __reader (long self, long sock, long handler, long arg);
    public int reader (long self, long sock, long handler, long arg) {
        return __reader (self, sock, handler, arg);
    }
    /*
    Cancel a socket reader from the reactor. If multiple readers exist for
    same socket, cancels ALL of them.                                     
    */
    native static void __reader_end (long self, long sock);
    public void readerEnd (long self, long sock) {
        __reader_end (self, sock);
    }
    /*
    Configure a registered reader to ignore errors. If you do not set this,
    then readers that have errors are removed from the reactor silently.   
    */
    native static void __reader_set_tolerant (long self, long sock);
    public void readerSetTolerant (long self, long sock) {
        __reader_set_tolerant (self, sock);
    }
    /*
    Register a timer that expires after some delay and repeats some number of
    times. At each expiry, will call the handler, passing the arg. To run a  
    timer forever, use 0 times. Returns a timer_id that is used to cancel the
    timer in the future. Returns -1 if there was an error.                   
    */
    native static int __timer (long self, long delay, long times, long handler, long arg);
    public int timer (long self, long delay, long times, long handler, long arg) {
        return __timer (self, delay, times, handler, arg);
    }
    /*
    Cancel a specific timer identified by a specific timer_id (as returned by
    zloop_timer).                                                            
    */
    native static int __timer_end (long self, int timerId);
    public int timerEnd (long self, int timerId) {
        return __timer_end (self, timerId);
    }
    /*
    Register a ticket timer. Ticket timers are very fast in the case where   
    you use a lot of timers (thousands), and frequently remove and add them. 
    The main use case is expiry timers for servers that handle many clients, 
    and which reset the expiry timer for each message received from a client.
    Whereas normal timers perform poorly as the number of clients grows, the 
    cost of ticket timers is constant, no matter the number of clients. You  
    must set the ticket delay using zloop_set_ticket_delay before creating a 
    ticket. Returns a handle to the timer that you should use in             
    zloop_ticket_reset and zloop_ticket_delete.                              
    */
    native static long __ticket (long self, long handler, long arg);
    public long ticket (long self, long handler, long arg) {
        return __ticket (self, handler, arg);
    }
    /*
    Reset a ticket timer, which moves it to the end of the ticket list and
    resets its execution time. This is a very fast operation.             
    */
    native static void __ticket_reset (long self, long handle);
    public void ticketReset (long self, long handle) {
        __ticket_reset (self, handle);
    }
    /*
    Delete a ticket timer. We do not actually delete the ticket here, as    
    other code may still refer to the ticket. We mark as deleted, and remove
    later and safely.                                                       
    */
    native static void __ticket_delete (long self, long handle);
    public void ticketDelete (long self, long handle) {
        __ticket_delete (self, handle);
    }
    /*
    Set the ticket delay, which applies to all tickets. If you lower the   
    delay and there are already tickets created, the results are undefined.
    */
    native static void __set_ticket_delay (long self, long ticketDelay);
    public void setTicketDelay (long self, long ticketDelay) {
        __set_ticket_delay (self, ticketDelay);
    }
    /*
    Set hard limit on number of timers allowed. Setting more than a small  
    number of timers (10-100) can have a dramatic impact on the performance
    of the reactor. For high-volume cases, use ticket timers. If the hard  
    limit is reached, the reactor stops creating new timers and logs an    
    error.                                                                 
    */
    native static void __set_max_timers (long self, long maxTimers);
    public void setMaxTimers (long self, long maxTimers) {
        __set_max_timers (self, maxTimers);
    }
    /*
    Set verbose tracing of reactor on/off
    */
    native static void __set_verbose (long self, boolean verbose);
    public void setVerbose (long self, boolean verbose) {
        __set_verbose (self, verbose);
    }
    /*
    Start the reactor. Takes control of the thread and returns when the 0MQ  
    context is terminated or the process is interrupted, or any event handler
    returns -1. Event handlers may register new sockets and timers, and      
    cancel sockets. Returns 0 if interrupted, -1 if cancelled by a handler.  
    */
    native static int __start (long self);
    public int start (long self) {
        return __start (self);
    }
    /*
    Ignore zsys_interrupted flag in this loop. By default, a zloop_start will 
    exit as soon as it detects zsys_interrupted is set to something other than
    zero. Calling zloop_ignore_interrupts will supress this behavior.         
    */
    native static void __ignore_interrupts (long self);
    public void ignoreInterrupts (long self) {
        __ignore_interrupts (self);
    }
    /*
    Self test of this class.
    */
    native static void __test (boolean verbose);
    public void test (boolean verbose) {
        __test (verbose);
    }
}
