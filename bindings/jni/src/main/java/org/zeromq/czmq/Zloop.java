/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/
package org.zeromq.czmq;

public class Zloop implements AutoCloseable {
    static {
        try {
            System.loadLibrary ("czmqjni");
        }
        catch (Exception e) {
            System.exit (-1);
        }
    }
    long self;

    /*
    Create a new zloop reactor
    */
    native static long __init ();
    public Zloop () {
        /*  TODO: if __init fails, self is null...  */
        self = __init ();
    }
    /*
    Destroy a reactor
    */
    native static void __destroy (long self);
    @Override
    public void close() {
        __destroy (self);
        self = 0;
    }
    /*
    Cancel a socket reader from the reactor. If multiple readers exist for
    same socket, cancels ALL of them.                                     
    */
    native static void __reader_end (long self, Zsock sock);
    public void reader_end (long self, Zsock sock) {
        return Zloop.__reader_end (self, sock);
    }
    /*
    Configure a registered reader to ignore errors. If you do not set this,
    then readers that have errors are removed from the reactor silently.   
    */
    native static void __reader_set_tolerant (long self, Zsock sock);
    public void reader_set_tolerant (long self, Zsock sock) {
        return Zloop.__reader_set_tolerant (self, sock);
    }
    /*
    Cancel a specific timer identified by a specific timer_id (as returned by
    zloop_timer).                                                            
    */
    native static int __timer_end (long self, int timerId);
    public int timer_end (long self, int timerId) {
        return Zloop.__timer_end (self, timerId);
    }
    /*
    Reset a ticket timer, which moves it to the end of the ticket list and
    resets its execution time. This is a very fast operation.             
    */
    native static void __ticket_reset (long self, void * handle);
    public void ticket_reset (long self, void * handle) {
        return Zloop.__ticket_reset (self, handle);
    }
    /*
    Delete a ticket timer. We do not actually delete the ticket here, as    
    other code may still refer to the ticket. We mark as deleted, and remove
    later and safely.                                                       
    */
    native static void __ticket_delete (long self, void * handle);
    public void ticket_delete (long self, void * handle) {
        return Zloop.__ticket_delete (self, handle);
    }
    /*
    Set the ticket delay, which applies to all tickets. If you lower the   
    delay and there are already tickets created, the results are undefined.
    */
    native static void __set_ticket_delay (long self, long ticketDelay);
    public void set_ticket_delay (long self, long ticketDelay) {
        return Zloop.__set_ticket_delay (self, ticketDelay);
    }
    /*
    Set hard limit on number of timers allowed. Setting more than a small  
    number of timers (10-100) can have a dramatic impact on the performance
    of the reactor. For high-volume cases, use ticket timers. If the hard  
    limit is reached, the reactor stops creating new timers and logs an    
    error.                                                                 
    */
    native static void __set_max_timers (long self, long maxTimers);
    public void set_max_timers (long self, long maxTimers) {
        return Zloop.__set_max_timers (self, maxTimers);
    }
    /*
    Set verbose tracing of reactor on/off
    */
    native static void __set_verbose (long self, boolean verbose);
    public void set_verbose (long self, boolean verbose) {
        return Zloop.__set_verbose (self, verbose);
    }
    /*
    Start the reactor. Takes control of the thread and returns when the 0MQ  
    context is terminated or the process is interrupted, or any event handler
    returns -1. Event handlers may register new sockets and timers, and      
    cancel sockets. Returns 0 if interrupted, -1 if cancelled by a handler.  
    */
    native static int __start (long self);
    public int start (long self) {
        return Zloop.__start (self);
    }
    /*
    Ignore zsys_interrupted flag in this loop. By default, a zloop_start will 
    exit as soon as it detects zsys_interrupted is set to something other than
    zero. Calling zloop_ignore_interrupts will supress this behavior.         
    */
    native static void __ignore_interrupts (long self);
    public void ignore_interrupts (long self) {
        return Zloop.__ignore_interrupts (self);
    }
    /*
    Self test of this class.
    */
    native static void __test (boolean verbose);
    public void test (boolean verbose) {
        return Zloop.__test (verbose);
    }
}
