zsocket(7)
==========

NAME
----
zsocket - working with 0MQ sockets

SYNOPSIS
--------
----
//  Create a new socket within our libzapi context, replaces zmq_socket.
//  If the socket is a SUB socket, automatically subscribes to everything.
//  Use this to get automatic management of the socket at shutdown.
void *
    zsocket_new (zctx_t *self, int type);

//  Destroy a socket within our libzapi context, replaces zmq_close.
void
    zsocket_destroy (zctx_t *self, void *socket);

//  Bind a socket to a formatted endpoint
//  Checks with assertion that the bind was valid
void
    zsocket_bind (void *socket, const char *format, ...);

//  Connect a socket to a formatted endpoint
//  Checks with assertion that the connect was valid
void
    zsocket_connect (void *socket, const char *format, ...);

//  Self test of this class
int
    zsocket_test (Bool verbose);
----

DESCRIPTION
-----------

The zsocket class provides helper functions for 0MQ sockets. It doesn't
wrap the 0MQ socket type, to avoid breaking all libzmq socket-related
calls. Automatically subscribes SUB sockets to "".


EXAMPLE
-------
.From zsocket_test method
----
    zctx_t *ctx = zctx_new ();

    //  Create a detached thread, let it run
    char *interface = "*";
    char *domain = "localhost";
    int service = 5555;

    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_bind (publisher, "tcp://%s:%d", interface, service);
    zsocket_connect (subscriber, "tcp://%s:%d", domain, service);
    assert (zsockopt_type (publisher) == ZMQ_PUB);
    zclock_sleep (100);
    zstr_send (publisher, "HELLO");
    char *message = zstr_recv (subscriber);
    assert (message);
    assert (streq (message, "HELLO"));
    free (message);
    zsocket_destroy (ctx, publisher);

    zctx_destroy (&ctx);
----

SEE ALSO
--------
linkzapi:zapi[7]
